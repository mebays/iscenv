
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ontariosystems/isclib/isclib.go (12.5%)</option>
				
				<option value="file1">github.com/ontariosystems/isclib/ensureuserisroot.go (0.0%)</option>
				
				<option value="file2">github.com/ontariosystems/isclib/importdescription.go (96.0%)</option>
				
				<option value="file3">github.com/ontariosystems/isclib/instance.go (12.9%)</option>
				
				<option value="file4">github.com/ontariosystems/isclib/instances.go (0.0%)</option>
				
				<option value="file5">github.com/ontariosystems/isclib/instancestatus.go (100.0%)</option>
				
				<option value="file6">github.com/ontariosystems/isclib/parametersisc.go (100.0%)</option>
				
				<option value="file7">github.com/ontariosystems/isclib/qlist.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package isclib

// TODO: Consider making a pass through this entire library and using errwrap where appropriate

import (
        "bufio"
        "bytes"
        "os/exec"

        "github.com/Sirupsen/logrus"
)

const (
        defaultCControlPath = "ccontrol"
        defaultCSessionPath = "csession"
        cacheParametersFile = "parameters.isc"
)

const (
        // This is the string which will be piped into a csession command to load the actual code to be executed into an in-memory buffer from a file.
        codeImportString = `try { ` +
                `znspace "%s" ` +
                `set f="%s" ` +
                `open f:"R":1 ` +
                `if $test { use f zload  close f do MAIN halt } ` +
                `else { do $zutil(4, $job, 98) } } ` +
                `catch ex { ` +
                `do BACK^%%ETN ` +
                `use 0 ` +
                `write !,"Exception: ",ex.DisplayString(),!,` +
                `"  name: ",ex.Name,!,` +
                `"  code: ",ex.Code,! ` +
                `do $zutil(4, $job, 99) ` +
                `}`

        importWrapper = `MAIN
 new
 set s=%s
 if $system.Status.IsError(s) {
         set ecs=$system.Status.GetErrorCodes(s)
         write !!!,"*******************",!,ecs,!
         if ($length(ecs,",")'=1) || (ecs'=11) {
           do $system.Status.DisplayStatus(s)
           do $zutil(4,$job,2)
   }
 }
 quit

`
)

var (
        globalCControlPath = defaultCControlPath
        globalCSessionPath = defaultCSessionPath
)

// CControlPath returns the current path to the ccontrol executable
func CControlPath() string <span class="cov0" title="0">{ return globalCControlPath }</span>

// SetCControlPath sets the current path to the ccontrol executable
func SetCControlPath(path string) <span class="cov0" title="0">{
        globalCControlPath = path
}</span>

// CSessionPath returns the current path to the csession executable
func CSessionPath() string <span class="cov0" title="0">{ return globalCSessionPath }</span>

// SetCSessionPath sets the current path to the csession executable
func SetCSessionPath(path string) <span class="cov0" title="0">{
        globalCSessionPath = path
}</span>

// ISCExists returns a boolean which is true when an ISC product or Caché instance exists on this system.
func ISCExists() bool <span class="cov0" title="0">{
        if _, err := exec.LookPath(globalCControlPath); err != nil </span><span class="cov0" title="0">{
                log.WithField("ccontrolPath", globalCControlPath).WithError(err).Debug("ccontrol executable not found")
                return false
        }</span>

        <span class="cov0" title="0">if _, err := exec.LookPath(globalCSessionPath); err != nil </span><span class="cov0" title="0">{
                log.WithField("csessionPath", globalCControlPath).WithError(err).Debug("csession executable not found")
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// LoadInstances returns a listing of all Caché/Ensemble instances on this system.
// It returns the list of instances and any error encountered.
func LoadInstances() (Instances, error) <span class="cov0" title="0">{
        qs, err := qlist("")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">instances := make(Instances, 0)
        scanner := bufio.NewScanner(bytes.NewBufferString(qs))
        for scanner.Scan() </span><span class="cov0" title="0">{
                instance, err := InstanceFromQList(scanner.Text())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">instances = append(instances, instance)</span>
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return instances, nil</span>
}

// LoadInstance retrieves a single instance by name.
// The instance name is case insensitive.
// It returns the instance and any error encountered.
func LoadInstance(name string) (*Instance, error) <span class="cov0" title="0">{
        q, err := qlist(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return InstanceFromQList(q)</span>
}

// InstanceFromQList will parse the output of a ccontrol qlist into an Instance struct.
// It expects the results of a ccontrol qlist for a single instance as a string.
// It returns the parsed instance and any error encountered.
func InstanceFromQList(qlist string) (*Instance, error) <span class="cov10" title="2">{
        i := new(Instance)
        if err := i.UpdateFromQList(qlist); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return i, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package isclib

import (
        "fmt"
        "os/user"
)

func ensureUserIsRoot() error <span class="cov0" title="0">{
        user, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if user.Uid != "0" </span><span class="cov0" title="0">{
                return fmt.Errorf("Must be run as root")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package isclib

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "strings"
)

const (
        importFmtStr = `##class(%%SYSTEM.OBJ).ImportDir("%s","%s","%s",,%d)`
)

var (
        TooManyRecursiveDirsErr   = errors.New("The glob must contain at most one **")
        MissingPathSeparatorErr   = errors.New("There must be a path separator between ** and file pattern")
        PathAfterRecursiveDirsErr = errors.New("A ** must only be used as the last portion of the path before the file pattern")
        WildcardInDirectoryErr    = errors.New("The directory portion of the glob must not contain *")
)

type ImportDescription struct {
        Dir         string
        FilePattern string
        Recursive   bool
        Qualifiers  string
}

func NewImportDescription(pathGlob string, qualifiers string) (*ImportDescription, error) <span class="cov10" title="11">{
        glob := &amp;ImportDescription{Qualifiers: qualifiers}

        s := strings.Split(pathGlob, "**")
        switch len(s) </span>{
        <span class="cov6" title="4">case 1:
                glob.Dir = filepath.Dir(s[0])
                glob.FilePattern = filepath.Base(s[0])</span>
        <span class="cov7" title="6">case 2:
                glob.Dir = filepath.Clean(s[0])
                if !strings.HasPrefix(s[1], "/") </span><span class="cov1" title="1">{
                        return nil, MissingPathSeparatorErr
                }</span>

                <span class="cov7" title="5">if filepath.Dir(s[1]) != "/" </span><span class="cov1" title="1">{
                        return nil, PathAfterRecursiveDirsErr
                }</span>
                <span class="cov6" title="4">glob.FilePattern = filepath.Base(s[1])
                glob.Recursive = true</span>
        <span class="cov1" title="1">default:
                return nil, TooManyRecursiveDirsErr</span>
        }

        <span class="cov8" title="8">if strings.Contains(glob.Dir, "*") </span><span class="cov3" title="2">{
                return nil, WildcardInDirectoryErr
        }</span>

        <span class="cov7" title="6">if glob.Dir == "." </span><span class="cov3" title="2">{
                if cwd, err := os.Getwd(); err == nil </span><span class="cov3" title="2">{
                        glob.Dir = cwd
                }</span><span class="cov0" title="0"> else {
                        return nil, err
                }</span>
        }

        <span class="cov7" title="6">return glob, nil</span>
}

func (i *ImportDescription) String() string <span class="cov3" title="2">{
        var rec uint16
        if i.Recursive </span><span class="cov1" title="1">{
                rec = 1
        }</span><span class="cov1" title="1"> else {
                rec = 0
        }</span>
        <span class="cov3" title="2">return fmt.Sprintf(importFmtStr, i.Dir, i.FilePattern, i.Qualifiers, rec)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package isclib

import (
        "bytes"
        "fmt"
        "io"
        "io/ioutil"
        "os"
        "os/exec"
        "os/user"
        "path/filepath"
        "strconv"
        "strings"
        "syscall"

        "github.com/Sirupsen/logrus"
)

const (
        managerUserKey          = "security_settings.manager_user"
        managerGroupKey         = "security_settings.manager_group"
        ownerUserKey            = "security_settings.cache_user"
        ownerGroupKey           = "security_settings.cache_group"
        DefaultImportQualifiers = "/compile/keepsource/expand/multicompile"
)

// An Instance represents an instance of Caché/Ensemble on the current system.
type Instance struct {
        // Required to be able to run the executor
        CSessionPath string `json:"-"` // The path to the csession executable
        CControlPath string `json:"-"` // The path to the ccontrol executable

        // These values come directly from ccontrol qlist
        Name            string         `json:"name"`            // The name of the instance
        Directory       string         `json:"directory"`       // The directory in which the instance is installed
        Version         string         `json:"version"`         // The version of Caché/Ensemble
        Status          InstanceStatus `json:"status"`          // The status of the instance (down, running, etc.)
        Activity        string         `json:"activity"`        // The last activity date and time (as a string)
        CPFFileName     string         `json:"cpfFileName"`     // The name of the CPF file used by this instance at startup
        SuperServerPort int            `json:"superServerPort"` // The SuperServer port
        WebServerPort   int            `json:"webServerPort"`   // The internal WebServer port
        JDBCPort        int            `json:"jdbcPort"`        // The JDBC port
        State           string         `json:"state"`           // The State of the instance (warn, etc.)
        // There appears to be an additional property after state but I don't know what it is!

        executionSysProcAttr *syscall.SysProcAttr // This is used internally to allow execution of Caché code as different users
}

// Update will query the the underlying instance and update the Instance fields with its current state.
// It returns any error encountered.
func (i *Instance) Update() error <span class="cov0" title="0">{
        q, err := qlist(i.Name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return i.UpdateFromQList(q)</span>
}

// UpdateFromQList will update the current Instance with the values from the qlist string.
// It returns any error encountered.
func (i *Instance) UpdateFromQList(qlist string) (err error) <span class="cov10" title="2">{
        qs := strings.Split(qlist, "^")
        if len(qs) &lt; 9 </span><span class="cov1" title="1">{
                return fmt.Errorf("Insufficient pieces in qlist, need at least 9, qlist: %s", qlist)
        }</span>

        <span class="cov1" title="1">if i.SuperServerPort, err = strconv.Atoi(qs[5]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if i.WebServerPort, err = strconv.Atoi(qs[6]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">if i.JDBCPort, err = strconv.Atoi(qs[7]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov1" title="1">i.Name = qs[0]
        i.Directory = qs[1]
        i.Version = qs[2]
        i.Status, i.Activity = qlistStatus(qs[3])
        i.CPFFileName = qs[4]
        i.State = qs[8]

        return nil</span>
}

// DetermineManager will determine the manager of an instance by reading the parameters file associated with this instance.
// The manager is the primary user of the instance that will be able to perform start/stop operations etc.
// It returns the manager and manager group as strings and any error encountered.
func (i *Instance) DetermineManager() (string, string, error) <span class="cov0" title="0">{
        return i.getUserAndGroupFromParameters("Manager", managerUserKey, managerGroupKey)
}</span>

// DetermineOwner will determine the owner of an instance by reader the parameters file associate with this instance.
// The owner is the user which owns the files from the installers and as who most Caché processes will be running.
// It returns the owner and owner group as strings and any error encountered.
func (i *Instance) DetermineOwner() (string, string, error) <span class="cov0" title="0">{
        return i.getUserAndGroupFromParameters("Owner", ownerUserKey, ownerGroupKey)
}</span>

// Start will ensure that an instance is started.
// It returns any error encountered when attempting to start the instance.
func (i *Instance) Start() error <span class="cov0" title="0">{
        // TODO: Think about a nozstu flag if there's a reason
        if i.Status.Down() </span><span class="cov0" title="0">{
                if output, err := exec.Command(i.ccontrolPath(), "start", i.Name, "quietly").CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error starting instance, error: %s, output: %s", err, output)
                }</span>
        }

        <span class="cov0" title="0">if err := i.Update(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error refreshing instance state during start, error: %s", err)
        }</span>

        <span class="cov0" title="0">if !i.Status.Ready() </span><span class="cov0" title="0">{
                return fmt.Errorf("Failed to start instance, name: %s, status: %s", i.Name, i.Status)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop will ensure that an instance is started.
// It returns any error encountered when attempting to stop the instance.
func (i *Instance) Stop() error <span class="cov0" title="0">{
        ilog := log.WithField("name", i.Name)
        ilog.Debug("Shutting down instance")
        if i.Status.Up() </span><span class="cov0" title="0">{
                args := []string{"stop", i.Name}
                if i.Status.RequiresBypass() </span><span class="cov0" title="0">{
                        args = append(args, "bypass")
                }</span>
                <span class="cov0" title="0">args = append(args, "quietly")
                if output, err := exec.Command(i.ccontrolPath(), args...).CombinedOutput(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error stopping instance, error: %s, output: %s", err, output)
                }</span>
        }

        <span class="cov0" title="0">if err := i.Update(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("Error refreshing instance state during stop, error: %s", err)
        }</span>

        <span class="cov0" title="0">if !i.Status.Down() </span><span class="cov0" title="0">{
                return fmt.Errorf("Failed to stop instance, name: %s, status: %s", i.Name, i.Status)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ExecuteAsCurrentUser will configure the instance to execute all future commands as the current user.
// It returns any error encountered.
func (i *Instance) ExecuteAsCurrentUser() error <span class="cov0" title="0">{
        log.Debug("Removing execution user")
        i.executionSysProcAttr = nil
        return nil
}</span>

// ExecuteAsManager will  configure the instance to execute all future commands as the instance's owner.
// This command only functions if the calling program is running as root.
// It returns any error encountered.
func (i *Instance) ExecuteAsManager() error <span class="cov0" title="0">{
        owner, _, err := i.DetermineManager()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return i.ExecuteAsUser(owner)</span>
}

// ExecuteAsUser will  configure the instance to execute all future commands as the provided user.
// This command only functions if the calling program is running as root.
// It returns any error encountered.
func (i *Instance) ExecuteAsUser(execUser string) error <span class="cov0" title="0">{
        if err := ensureUserIsRoot(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">u, err := user.Lookup(execUser)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">uid, err := strconv.ParseUint(u.Uid, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">gid, err := strconv.ParseUint(u.Gid, 10, 32)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">log.WithFields(log.Fields{"user": execUser, "uid": u.Uid, "gid": u.Gid}).Debug("Configured to execute as alternate user")
        i.executionSysProcAttr = &amp;syscall.SysProcAttr{
                Credential: &amp;syscall.Credential{
                        Uid: uint32(uid),
                        Gid: uint32(gid),
                },
        }
        return nil</span>
}

// ImportSource will import the source from a single Caché XML file into the provided namespace
//
func (i *Instance) ImportSource(namespace, sourcePathGlob string, qualifiers ...string) (string, error) <span class="cov0" title="0">{
        qstr := strings.TrimSpace(strings.Join(qualifiers, ""))
        if qstr == "" </span><span class="cov0" title="0">{
                qstr = DefaultImportQualifiers
        }</span>

        <span class="cov0" title="0">id, err := NewImportDescription(sourcePathGlob, qstr)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">cmd := id.String()
        log.WithField("command", cmd).Debug("Attempting to import source")
        return i.ExecuteString(namespace, fmt.Sprintf(importWrapper, cmd))</span>
}

// Execute will read code from the provided io.Reader ane execute it in the provided namespace.
// The code must be valid Caché ObjectScript INT code obeying all of the correct spacing with a MAIN label as the primary entry point.
// Valid INT code means (this list is not exhaustive)...
//   - Labels start at the first character on the line
//   - Non-labels start with a single space
//   - You may not have blank lines internal to the code
//   - You must have a single blank line at the end of the script
// It returns any output of the execution and any error encountered.
func (i *Instance) Execute(namespace string, codeReader io.Reader) (string, error) <span class="cov0" title="0">{
        // TODO: Async standard out from csession
        elog := log.WithField("namespace", namespace)
        elog.Debug("Attempting to execute INT code")

        codePath, err := i.genExecutorTmpFile(codeReader)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">elog.WithField("path", codePath).Debug("Acquired temporary file")

        defer os.Remove(codePath)

        // Not using -U because it won't work if the user has a startup namespace
        cmd := exec.Command(i.csessionPath(), i.Name)

        if i.executionSysProcAttr != nil </span><span class="cov0" title="0">{
                cmd.SysProcAttr = i.executionSysProcAttr
        }</span>

        <span class="cov0" title="0">in, err := cmd.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var out bytes.Buffer
        cmd.Stdout = &amp;out

        if err := cmd.Start(); err != nil </span><span class="cov0" title="0">{
                log.WithError(err).Debug("Failed to start csession")
                return "", err
        }</span>

        <span class="cov0" title="0">importString := fmt.Sprintf(codeImportString, namespace, codePath)
        // TODO: Consider parsing the code and correcting indenting/spacing/etc
        elog.WithField("importCode", importString).Debug("Attempting to load INT code into buffer")
        if count, err := in.Write([]byte(importString)); err != nil </span><span class="cov0" title="0">{
                log.WithError(err).WithField("count", count).Debug("Attempted to write to csession stdin and failed")
                return "", err
        }</span>
        // TODO: Add the required blank line at the end of the int code if it is missing
        <span class="cov0" title="0">in.Close()

        elog.Debug("Waiting on csession to exit")
        err = cmd.Wait()
        return out.String(), err</span>
}

// ExecuteString will execute the provided code in the specified namespace.
// code must be properly formatted INT code. See the documentation for Execute for more information.
// It returns any output of the execution and any error encountered.
func (i *Instance) ExecuteString(namespace string, code string) (string, error) <span class="cov0" title="0">{
        b := bytes.NewReader([]byte(code))
        return i.Execute(namespace, b)
}</span>

// ReadParametersISC will read the current instances parameters ISC file into a simple data structure.
// It returns the ParametersISC data structure and any error encountered.
func (i *Instance) ReadParametersISC() (ParametersISC, error) <span class="cov0" title="0">{
        pfp := filepath.Join(i.Directory, cacheParametersFile)
        f, err := os.Open(pfp)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        return LoadParametersISC(f)</span>
}

func qlistStatus(statusAndTime string) (InstanceStatus, string) <span class="cov1" title="1">{
        s := strings.SplitN(statusAndTime, ",", 2)
        var a string
        if len(s) &gt; 1 </span><span class="cov1" title="1">{
                a = strings.TrimSpace(s[1])
        }</span>
        <span class="cov1" title="1">return InstanceStatus(strings.ToLower(s[0])), a</span>
}

func (i *Instance) genExecutorTmpFile(codeReader io.Reader) (string, error) <span class="cov0" title="0">{
        tmpFile, err := ioutil.TempFile("", "isclib-exec-")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">defer tmpFile.Close()

        if _, err := io.Copy(tmpFile, codeReader); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Need to set the permissions here or the file will be owned by root and the execution will fail
        <span class="cov0" title="0">if i.executionSysProcAttr != nil </span><span class="cov0" title="0">{
                if err := os.Chown(
                        tmpFile.Name(),
                        int(i.executionSysProcAttr.Credential.Uid),
                        int(i.executionSysProcAttr.Credential.Gid),
                ); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        <span class="cov0" title="0">return tmpFile.Name(), nil</span>
}

func (i *Instance) csessionPath() string <span class="cov0" title="0">{
        if i.CSessionPath == "" </span><span class="cov0" title="0">{
                return globalCSessionPath
        }</span>

        <span class="cov0" title="0">return i.CSessionPath</span>
}

func (i *Instance) ccontrolPath() string <span class="cov0" title="0">{
        if i.CControlPath == "" </span><span class="cov0" title="0">{
                return globalCControlPath
        }</span>

        <span class="cov0" title="0">return i.CControlPath</span>
}

func (i *Instance) getUserAndGroupFromParameters(desc, userKey, groupKey string) (string, string, error) <span class="cov0" title="0">{
        pi, err := i.ReadParametersISC()
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov0" title="0">owner := pi.Value(userKey)
        if owner == "" </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("%s user not found in parameters file", desc)
        }</span>

        <span class="cov0" title="0">group := pi.Value(groupKey)
        if group == "" </span><span class="cov0" title="0">{
                return "", "", fmt.Errorf("%s group not found in parameters file", desc)
        }</span>

        <span class="cov0" title="0">return owner, group, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package isclib

// Instances represents a collection of Caché/Ensemble instances
type Instances []*Instance

// Update will query the underlying instances and update the Instance fields with their current values.
// It returns any error encountered.
func (instances Instances) Update() error <span class="cov0" title="0">{
        for _, instance := range instances </span><span class="cov0" title="0">{
                if err := instance.Update(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package isclib

// An InstanceStatus represents one of the various status associated with Caché/Ensemble instances.
type InstanceStatus string

const (
        // InstanceStatusUnknown represents a blank/unknown instance status.
        InstanceStatusUnknown InstanceStatus = ""

        // InstanceStatusRunning represents a running instance.
        InstanceStatusRunning InstanceStatus = "running"

        // InstanceStatusInhibited represents an instance that is up but sign-ons have been inhibited due to an issue.
        InstanceStatusInhibited InstanceStatus = "sign-on inhibited"

        // InstanceStatusPrimaryTransition represents an instance that is up but the primary mirror memeber is being determined.
        InstanceStatusPrimaryTransition InstanceStatus = "sign-on inhibited:primary transition"

        // InstanceStatusDown represents an instance that is down.
        InstanceStatusDown InstanceStatus = "down"

        // InstanceStatusMissingIDS represents an instance that is up but missing a non-critical (but expected) information file.
        InstanceStatusMissingIDS InstanceStatus = "running on node ? (cache.ids missing)"
)

// Handled will return true when this status is a known and handled status.
func (iis InstanceStatus) Handled() bool <span class="cov10" title="7">{
        switch iis </span>{
        <span class="cov4" title="2">default:
                return false</span>
        <span class="cov8" title="5">case
                InstanceStatusRunning,
                InstanceStatusInhibited,
                InstanceStatusPrimaryTransition,
                InstanceStatusDown,
                InstanceStatusMissingIDS:
                return true</span>
        }
}

// Ready will return true if the status represents an acceptably running status.
func (iis InstanceStatus) Ready() bool <span class="cov10" title="7">{
        switch iis </span>{
        <span class="cov8" title="5">default:
                return false</span>
        <span class="cov4" title="2">case
                InstanceStatusRunning,
                InstanceStatusMissingIDS:
                return true</span>
        }
}

// Up will return true if status represents any up status (even unclean states like sign-on inhibited)
func (iis InstanceStatus) Up() bool <span class="cov10" title="7">{
        switch iis </span>{
        <span class="cov6" title="3">default:
                return false</span>
        <span class="cov7" title="4">case
                InstanceStatusRunning,
                InstanceStatusInhibited,
                InstanceStatusPrimaryTransition,
                InstanceStatusMissingIDS:
                return true</span>
        }
}

// Down will return true if the instance status represents a fully down instance.
func (iis InstanceStatus) Down() bool <span class="cov10" title="7">{
        switch iis </span>{
        <span class="cov9" title="6">default:
                return false</span>
        <span class="cov1" title="1">case
                InstanceStatusDown:
                return true</span>
        }
}

// RequiresBypass returns true when a bypass is required to stop the instance
func (iis InstanceStatus) RequiresBypass() bool <span class="cov10" title="7">{
        switch iis </span>{
        <span class="cov8" title="5">default:
                return false</span>
        <span class="cov4" title="2">case
                InstanceStatusInhibited,
                InstanceStatusPrimaryTransition:
                return true</span>
        }
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package isclib

import (
        "bufio"
        "fmt"
        "io"
        "regexp"
        "strings"
)

var (
        parameterLineRegexp = regexp.MustCompile(`^\s*(?:([^.]+)\.)?(.+):\s*(.*)$`)
)

// ParametersISC represents the contents of the parameters ISC file
type ParametersISC map[string]ParametersISCGroup

// ParametersISCGroup represents a group of related parameters from the ISC file
type ParametersISCGroup map[string]*ParametersISCEntry

// ParametersISCEntry represents a single entry from the parameters ISC file
type ParametersISCEntry struct {
        // The group for this entry (the portion of the key before the .)
        Group string

        // The name of this entry (the portion of the key after the .)
        Name string

        // The values for this entry
        Values []string
}

// LoadParametersISC will load the parameters contained in the provided reader
// It returns the ParametersISC data structure and any error encountered
func LoadParametersISC(r io.Reader) (ParametersISC, error) <span class="cov4" title="3">{
        pi := make(ParametersISC)

        scanner := bufio.NewScanner(r)
        for scanner.Scan() </span><span class="cov9" title="17">{
                t := scanner.Text()
                if strings.TrimSpace(t) == "" </span><span class="cov6" title="5">{
                        continue</span>
                }
                <span class="cov8" title="12">m := parameterLineRegexp.FindStringSubmatch(t)
                if len(m) != 4 </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("Malformed parameter line: %s", t)
                }</span>

                <span class="cov8" title="11">group := m[1]
                name := m[2]
                value := m[3]
                if _, ok := pi[group]; !ok </span><span class="cov6" title="5">{
                        pi[group] = make(ParametersISCGroup)
                }</span>

                <span class="cov8" title="11">if _, ok := pi[group][name]; !ok </span><span class="cov7" title="9">{
                        pi[group][name] = &amp;ParametersISCEntry{
                                Group:  group,
                                Name:   name,
                                Values: make([]string, 0),
                        }
                }</span>

                <span class="cov8" title="11">pi[group][name].Values = append(pi[group][name].Values, value)</span>
        }

        <span class="cov3" title="2">if err := scanner.Err(); err != nil </span><span class="cov1" title="1">{
                return nil, err
        }</span>

        <span class="cov1" title="1">return pi, nil</span>
}

// Values will, given a set of identifiers making up a parameter key, return the values at that key
// Identifiers can be...
//  the full key (group.name)
//  the group, name as two separate parameters
//  A single parameter representing the name of a parameter in the "" group
// It returns the values at that key or an empty slice if it does not exist
func (pi ParametersISC) Values(identifiers ...string) []string <span class="cov10" title="18">{
        var group, name string
        switch len(identifiers) </span>{
        <span class="cov7" title="8">case 1:
                s := strings.Split(identifiers[0], ".")
                if len(s) == 1 </span><span class="cov5" title="4">{
                        group = ""
                        name = s[0]
                }</span><span class="cov5" title="4"> else {
                        group = s[0]
                        name = s[1]
                }</span>
        <span class="cov7" title="8">case 2:
                group = identifiers[0]
                name = identifiers[1]</span>
        <span class="cov3" title="2">default:
                return []string{}</span>
        }

        <span class="cov9" title="16">g := pi[group]
        if g == nil </span><span class="cov5" title="4">{
                return []string{}
        }</span>

        <span class="cov8" title="12">e := pi[group][name]
        if e == nil </span><span class="cov3" title="2">{
                return []string{}
        }</span>

        <span class="cov8" title="10">v := pi[group][name].Values
        if v == nil </span><span class="cov3" title="2">{
                return []string{}
        }</span>

        <span class="cov7" title="8">return v</span>
}

// Value will, given a set of identifiers making up a parameter key, return the single value at that key
// Identifiers can be...
//  the full key (group.name)
//  the group, name as two separate parameters
//  A single parameter representing the name of a parameter in the "" group
// It returns the value if a single value exists for the key or "" if it does not
func (pi ParametersISC) Value(identifiers ...string) string <span class="cov7" title="9">{
        values := pi.Values(identifiers...)
        if len(values) == 1 </span><span class="cov4" title="3">{
                return values[0]
        }</span>

        <span class="cov6" title="6">return ""</span>
}

// Key returns the full group.name key for this element
func (pie ParametersISCEntry) Key() string <span class="cov3" title="2">{
        if pie.Group == "" </span><span class="cov1" title="1">{
                return pie.Name
        }</span>

        <span class="cov1" title="1">return pie.Group + "." + pie.Name</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package isclib

import (
        "os/exec"
        "strings"
)

// qlist returns the results of executing ccontrol qlist for the specified instance.
// If instanceName is "", it will return the results of an argumentless qlist (which contains all instances)
// It returns a string containing the combined standard input and output of the qlist command and any error which occurred.
func qlist(instanceName string) (string, error) <span class="cov0" title="0">{
        // Example qlist output...
        // DOCKER^/ensemble/instances/docker/^2015.2.2.805.0.16216^down, last used Fri May 13 18:12:33 2016^cache.cpf^56772^57772^62972^^
        args := []string{"qlist"}
        if instanceName != "" </span><span class="cov0" title="0">{
                args = append(args, instanceName)
        }</span>

        <span class="cov0" title="0">out, err := exec.Command(globalCControlPath, args...).CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return strings.TrimSpace(string(out)), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
